#!/usr/bin/perl

use warnings;
use strict;

use Midnight::Game;

use IO::Prompt;
use Lingua::EN::Inflect qw(PL PL_V);

require Text::Wrap;
sub say (@) {
    local $Text::Wrap::columns;
    $Text::Wrap::columns = 80;

    print Text::Wrap::wrap('', '', @_), "\n";
}

my %commands_base = (
    commands    => \&cmd_commands,

    look        => \&cmd_look,
    describe    => \&cmd_describe,

    forward     => \&cmd_forward,

    left        => sub { turn("left") },
    right       => sub { turn("right") },

    north       => sub { face(Midnight::Map::Direction::NORTH) },
    northeast   => sub { face(Midnight::Map::Direction::NORTHEAST) },
    east        => sub { face(Midnight::Map::Direction::EAST) },
    southeast   => sub { face(Midnight::Map::Direction::SOUTHEAST) },
    south       => sub { face(Midnight::Map::Direction::SOUTH) },
    southwest   => sub { face(Midnight::Map::Direction::SOUTHWEST) },
    west        => sub { face(Midnight::Map::Direction::WEST) },
    northwest   => sub { face(Midnight::Map::Direction::NORTHWEST) },
);

my (%commands, %conflicts);
for my $key (keys %commands_base) {
    my @bits = split '', $key;
    pop @bits;

    my $cmd = "";
    while (my $bit = shift @bits) {
        $cmd .= $bit;
        if (exists $commands{$cmd}) {
            $conflicts{$cmd}->{$key} = 1;
            $conflicts{$cmd}->{$commands{$cmd}} = 1;
        }
        else {
            $commands{$cmd} = $key;
        }
    }
}
delete $commands{$_} for keys %conflicts;
map { $commands{$_} = $_; delete $conflicts{$_} } keys %commands_base;

my $cmd_regex_str = "(?:" . join("|", sort keys %commands) . ")";
my $cmd_regex = qr/^$cmd_regex_str$/i;

my $game = Midnight::Game->new;
my $map = $game->get_map;

my $me = $game->LUXOR;

look();

while (! $game->is_game_over) {
    my $cmd;
    while ($cmd = prompt "What now? ", -until => $cmd_regex) {
        if (exists $conflicts{$cmd}) {
            say "'$cmd' is ambiguous. Did you mean: " . join(" ", sort keys %{$conflicts{$cmd}});
        }
        else {
            say "Sorry, I don't understand '$cmd'.";
        }
    }

    $commands_base{$commands{$cmd}}->();
}

sub cmd_commands {
    say "Available commands: " . join(" ", sort keys %commands_base);
}

sub cmd_look {
    look();
}

sub cmd_describe {
    describe_location($me->get_location);
}

sub cmd_forward {
    if ($me->can_walk_forward) {
        $me->walk_forward;
        look();
    }
    else {
        say "He can't go that way!";
    }
}

sub turn {
    my ($turn) = @_;

    if ($turn eq "left") {
        $me->set_direction($me->get_direction->turn_left);
    }
    elsif ($turn eq "right") {
        $me->set_direction($me->get_direction->turn_right);
    }

    look();
}

sub face {
    my ($direction) = @_;

    $me->set_direction($direction);

    look();
}

sub look {
    my $location = $me->get_location;
    my $direction = $me->get_direction;

    my $looking = $map->get_looking_towards($location, $direction);

    say $me;
    say "He stands at $location looking $direction at $looking.";
    say "He is " . $me->get_condition . ".";
    say "The ice fear is " . $location->describe_ice_fear . ". " .
        $me->get_name . " is " . $me->get_courage . ".";
    say $me->get_time;

#    my @characters = grep { $_ != $me } @{$me->get_location->get_characters};
#    my $count = @characters;
#    if ($count > 0) {
#        say "There ".PL_V("is", $count)." $count ".PL("person", $count)." here: ".
#            join(" ", sort map { $_->get_name } @characters);
#    }
}

sub describe_location {
    my ($location) = @_;

    my $guard = $location->get_guard;
    if($guard) {
        say "$guard of the " . $guard->get_race . " guard the " . $location->get_feature . ".";
    }

    for my $c (@{$location->get_characters}) {
        next if $c == $me;

        my $line = "$c is here.";

        my $warriors = $c->get_warriors;
        my $riders = $c->get_riders;

        if ($warriors->get_how_many > 0 or $riders->get_how_many > 0) {
            $line .= " He commands ";

            if ($warriors->get_how_many > 0 and $riders->get_how_many > 0) {
                $line .= "$warriors and $riders";
            }
            elsif ($warriors->get_how_many > 0) {
                $line .= $warriors;
            }
            elsif ($riders->get_how_many > 0) {
                $line .= $riders;
            }
            
            $line .= " of the " . $c->get_race . ".";
        }

        say $line;
    }
}

